use bevy::prelude::*;
use crate::shared::AppState;
use shared::dto::game::{GameResult, GameScore, MatchResult, GameResultResponse};

#[cfg(target_arch = "wasm32")]
use web_sys::console;

// ================= Player Information =================

#[derive(Resource, Default)]
pub struct PlayerInfo {
    pub username: String,
    pub wallet_address: String,
}

impl PlayerInfo {
    pub fn new(username: String, wallet_address: String) -> Self {
        Self {
            username,
            wallet_address,
        }
    }
}

// ================= Score Management =================

#[derive(Resource, Default)]
pub struct Score {
    pub left_team: u32,
    pub right_team: u32,
    pub high_score: u32,
}

impl Score {
    pub fn new() -> Self {
        Self {
            left_team: 0,
            right_team: 0,
            high_score: 0,
        }
    }

    pub fn add_point(&mut self, team: GoalTeam) {
        match team {
            GoalTeam::Left => self.left_team += 1,
            GoalTeam::Right => self.right_team += 1,
        }
        let total = self.left_team + self.right_team;
        if total > self.high_score {
            self.high_score = total;
        }
    }

    pub fn reset(&mut self) {
        self.left_team = 0;
        self.right_team = 0;
    }

    pub fn get_winner(&self) -> Option<GoalTeam> {
        if self.left_team >= 5 {
            Some(GoalTeam::Left)
        } else if self.right_team >= 5 {
            Some(GoalTeam::Right)
        } else {
            None
        }
    }

    pub fn is_match_point(&self) -> bool {
        self.left_team >= 4 || self.right_team >= 4
    }
}

// ================= Game Timer =================

#[derive(Resource)]
pub struct GameTimer {
    pub remaining_time: f32,
    pub match_duration: f32,
    pub is_finished: bool,
}

impl Default for GameTimer {
    fn default() -> Self {
        Self {
            remaining_time: 120.0, // 2 minutes
            match_duration: 120.0,
            is_finished: false,
        }
    }
}

// ================= Score Notifications =================

#[derive(Resource, Default)]
pub struct ScoreNotifications {
    pub notifications: Vec<ScoreNotification>,
}

#[derive(Clone)]
pub struct ScoreNotification {
    pub text: String,
    pub timer: f32,
    pub max_time: f32,
}

impl ScoreNotification {
    pub fn new(text: String, duration: f32) -> Self {
        Self {
            text,
            timer: duration,
            max_time: duration,
        }
    }
}

// ================= Events =================

#[derive(Event)]
pub struct GoalScored {
    pub goal_position: Vec3,
    pub scoring_team: GoalTeam,
}

#[derive(Event)]
pub struct MatchFinished {
    pub winner: Option<GoalTeam>,
}

#[derive(Event)]
pub struct PlayerReset;

// ================= Goal Team =================

#[derive(PartialEq, Eq, Clone, Debug)]
pub enum GoalTeam {
    Left,
    Right,
}

// ================= Scoring Systems =================

pub fn handle_goal_scored(
    mut score: ResMut<Score>,
    mut goal_events: EventReader<GoalScored>,
    mut notifications: ResMut<ScoreNotifications>,
    mut reset_events: EventWriter<PlayerReset>,
    mut match_events: EventWriter<MatchFinished>,
) {
    let event_count = goal_events.len();
    if event_count > 0 {
        println!("üéØ SCORING SYSTEM: Received {} GoalScored events!", event_count);
    }
    
    for event in goal_events.read() {
        println!("üéØ PROCESSING GoalScored event for {:?} team at {:?}", event.scoring_team, event.goal_position);
        score.add_point(event.scoring_team.clone());
        println!("üéØ ‚öΩ GOAL SCORED by {:?}! NEW SCORE: {} - {}", event.scoring_team, score.left_team, score.right_team);

        // Add floating notification
        let team_name = match event.scoring_team {
            GoalTeam::Left => "LEFT",
            GoalTeam::Right => "RIGHT",
        };
        notifications
            .notifications
            .push(ScoreNotification::new(format!("‚öΩ {} GOAL!", team_name), 2.0));

        // Check for match point
        if score.is_match_point() {
            notifications
                .notifications
                .push(ScoreNotification::new("üî• MATCH POINT!".to_string(), 2.0));
        }

        // Check for match winner
        if let Some(winner) = score.get_winner() {
            match_events.write(MatchFinished { winner: Some(winner) });
            return;
        }

        // Reset player positions after each goal
        reset_events.write(PlayerReset);
    }
}

pub fn reset_score_system(
    mut score: ResMut<Score>,
    mut timer: ResMut<GameTimer>,
    keyboard: Res<ButtonInput<KeyCode>>,
    mut notifications: ResMut<ScoreNotifications>,
    mut reset_events: EventWriter<PlayerReset>,
) {
    if keyboard.just_pressed(KeyCode::KeyR) {
        if score.left_team > 0 || score.right_team > 0 {
            notifications
                .notifications
                .push(ScoreNotification::new("üîÑ MATCH RESET".to_string(), 2.0));
        }
        score.reset();
        timer.remaining_time = timer.match_duration;
        timer.is_finished = false;
        reset_events.write(PlayerReset);
        println!("Match reset!");
    }
}

pub fn game_timer_system(
    mut timer: ResMut<GameTimer>,
    mut match_events: EventWriter<MatchFinished>,
    mut notifications: ResMut<ScoreNotifications>,
    time: Res<Time>,
    score: Res<Score>,
) {
    if timer.is_finished {
        return;
    }

    timer.remaining_time -= time.delta_secs();
    
    // Time warnings
    let time_left = timer.remaining_time as i32;
    if time_left == 30 && (timer.remaining_time - time_left as f32).abs() < 0.1 {
        notifications.notifications.push(ScoreNotification::new("‚è∞ 30 SECONDS!".to_string(), 2.0));
    } else if time_left == 10 && (timer.remaining_time - time_left as f32).abs() < 0.1 {
        notifications.notifications.push(ScoreNotification::new("‚è∞ 10 SECONDS!".to_string(), 2.0));
    }
    
    if timer.remaining_time <= 0.0 {
        timer.remaining_time = 0.0;
        timer.is_finished = true;
        
        // Determine winner by score
        let winner = if score.left_team > score.right_team {
            Some(GoalTeam::Left)
        } else if score.right_team > score.left_team {
            Some(GoalTeam::Right)
        } else {
            None // Draw
        };
        
        match_events.write(MatchFinished { winner });
    }
}

pub fn handle_match_finished(
    mut match_events: EventReader<MatchFinished>,
    mut notifications: ResMut<ScoreNotifications>,
    _next_state: ResMut<NextState<AppState>>,
) {
    for event in match_events.read() {
        match &event.winner {
            Some(GoalTeam::Left) => {
                notifications.notifications.push(ScoreNotification::new("üèÜ LEFT TEAM WINS!".to_string(), 5.0));
            },
            Some(GoalTeam::Right) => {
                notifications.notifications.push(ScoreNotification::new("üèÜ RIGHT TEAM WINS!".to_string(), 5.0));
            },
            None => {
                notifications.notifications.push(ScoreNotification::new("ü§ù DRAW!".to_string(), 5.0));
            }
        }
    }
}

pub fn _disabled_send_game_result_system(
    mut match_events: EventReader<MatchFinished>,
    score: Res<Score>,
    timer: Res<GameTimer>,
    player_info: Res<PlayerInfo>,
) {
    for event in match_events.read() {
        if player_info.username.is_empty() || player_info.wallet_address.is_empty() {
            println!("‚ö†Ô∏è Player info not set, skipping game result submission");
            continue;
        }

        let match_result = match &event.winner {
            Some(GoalTeam::Left) => MatchResult::Win, // Assuming player is always left team for single player
            Some(GoalTeam::Right) => MatchResult::Loss,
            None => MatchResult::Draw,
        };

        let game_result = GameResult::new(
            player_info.username.clone(),
            player_info.wallet_address.clone(),
            match_result,
            GameScore {
                left_team: score.left_team,
                right_team: score.right_team,
            },
            timer.match_duration - timer.remaining_time,
        );

        // For WASM, just log the result for now (HTTP requests would need different handling)
        #[cfg(target_arch = "wasm32")]
        {
            console::log_1(&format!("üéÆ Game result would be sent: {:?}", game_result).into());
        }

        // For native builds, spawn async task
        #[cfg(not(target_arch = "wasm32"))]
        {
            let client = reqwest::Client::new();
            let result_clone = game_result.clone();

            tokio::spawn(async move {
                match send_game_result_to_backend(client, result_clone).await {
                    Ok(_) => println!("‚úÖ Game result sent successfully"),
                    Err(e) => println!("‚ùå Failed to send game result: {}", e),
                }
            });
        }
    }
}

#[cfg(not(target_arch = \"wasm32\"))]\nasync fn send_game_result_to_backend(
    client: reqwest::Client,
    game_result: GameResult,
) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
    let response = client
        .post("http://127.0.0.1:3000/api/game/result")
        .json(&game_result)
        .send()
        .await?;

    if response.status().is_success() {
        let result: GameResultResponse = response.json().await?;
        println!("üéÆ Backend response: {}", result.message);
    } else {
        println!("‚ùå Backend returned error: {}", response.status());
    }

    Ok(())
}

// ================= Setup System =================

pub fn setup_player_info(mut player_info: ResMut<PlayerInfo>) {
    if player_info.username.is_empty() {
        // Set default player info for testing
        player_info.username = "test_player".to_string();
        player_info.wallet_address = "GCKFBEIYTKP33TO3QLCCKMXOMVK7X4PYC7_TEST_ADDRESS".to_string();
        println!("üéÆ Default player info set: {}", player_info.username);
    }
}

// ================= Scoring Plugin =================

pub struct ScoringPlugin;

impl Plugin for ScoringPlugin {
    fn build(&self, app: &mut App) {
        app
            // Add resources
            .init_resource::<Score>()
            .init_resource::<ScoreNotifications>()
            .init_resource::<GameTimer>()
            .init_resource::<PlayerInfo>()
            // Add events
            .add_event::<GoalScored>()
            .add_event::<MatchFinished>()
            .add_event::<PlayerReset>()
            // Add systems
            .add_systems(Startup, setup_player_info)
            .add_systems(
                Update,
                (
                    handle_goal_scored,
                    reset_score_system,
                    game_timer_system,
                    handle_match_finished,
                    // send_game_result_system, // Disabled for WASM compatibility
                ).run_if(in_state(AppState::InGame)),
            );
    }
}